declare module '@maidsafe/safe-node-app' {
  export = SafeNodeApp
}

/**
 * The AuthInterface contains all authentication related
 * functionality with the network. Like creating an authenticated
 * or unauthenticated connection or create messages for the IPC
 * authentitcation protocol.
 *
 * Access your instance through ypur {SAFEApp} instance under `.auth`.
 */
declare class AuthInterface {
  /**
   * The AuthInterface contains all authentication related
   * functionality with the network. Like creating an authenticated
   * or unauthenticated connection or create messages for the IPC
   * authentitcation protocol.
   *
   * Access your instance through ypur {SAFEApp} instance under `.auth`.
   */
  constructor(app: SAFEApp, initialisation: InitOptions);

  /**
   * Whether or not this is a registered/authenticated session.
   *
   * @returns {Boolean} true if this is an authenticated session
   */
  registered: any;

  /**
   * Generate an authentication URI for the app with
   * the given permissions and optional parameters.
   *
   * @param {Object} permissions - mapping the container-names
   *                  to a list of permissions you want to
   *                  request
   * @param {Object=} opts - optional parameters
   * @param {Boolean} [opts.own_container=false] - whether or not to request
   *    our own container to be created for us, too
   *
   * @returns {Object} `{id: <id>, uri: 'safe-auth://' }`
   * @example // using an Authentication example:
   * app.auth.genAuthUri({
   *  _public: ['Insert'], // request to insert into public
   *  _other: ['Insert', 'Update'] // request to insert and update
   * }, {own_container: true}) // and we want our own container, too
   */
  genAuthUri(permissions: Object, opts?: { own_container: Boolean }): Object;

  /**
   * Generate a `'safe-auth'`-URI to request permissions
   * on arbitrary owned MutableData's.
   *
   * @param {Object} permissions - mapping the MutableData's XoR names
   *                  to a list of permissions you want to request
   *
   * @returns {String} `safe-auth://`-URI
   * @example // example of requesting permissions for a couple of MutableData's:
   * app.auth.genShareMDataUri([
   *  { typeTag: 15001,   // request for MD with tag 15001
   *    name: 'XoRname1',  // request for MD located at address 'XoRname1'
   *    perms: ['Insert'], // request for inserting into the referenced MD
   *  },
   *  { typeTag: 15020,   // request for MD with tag 15020
   *    name: 'XoRname2',  // request for MD located at address 'XoRname2'
   *    perms: ['Insert', `Update`], // request for updating and inserting into the referenced MD
   *  }
   * ])
   */
  genShareMDataUri(permissions: Object): String;

  /**
   * Generate a `'safe-auth'`-URI to request further container permissions
   *
   * @example // generating a container authorisation URI:
   * app.auth.genContainerAuthUri(
   *  _publicNames: ['Insert'], // request to insert into publicNames
   * })
   * @returns {String}
   * @arg {Object} containers mapping container name to list of permissions
   */
  genContainerAuthUri(containers: Object): String;

  /**
   * Refresh the access persmissions from the network. Useful when you just
   * connected or received a response from the authenticator in the IPC protocol.
   * @return {Promise}
   */
  refreshContainersPermissions(): Promise<void>;

  /**
   * Get the names of all containers found and the app's granted
   * permissions for each of them.
   *
   * @return {Promise<Array>}
   */
  getContainersPermissions(): Promise<Array<any>>;

  /**
   * Read granted containers permissions from an auth URI
   * without the need to connect to the network.
   * @arg {String} uri the IPC response string given
   *
   * @return {Promise<Array>}
   */
  readGrantedPermissions(uri: String): Promise<Array<any>>;

  /**
   * Get the MutableData for the app's own container generated by Authenticator.
   * When run in tests, this falls back to the randomly generated version
   * @return {Promise<MutableData>}
   */
  getOwnContainer(): Promise<MutableData>;

  /**
   * Whether or not this session has specifc access permission for a given container.
   * @arg {String} name  name of the container, e.g. `'_public'`
   * @arg {(String|Array<String>)} [permissions=['Read']] permissions to check for
   * @returns {Promise<boolean>}
   */
  canAccessContainer(name: String, permissions?: (String | String[])): Promise<boolean>;

  /**
   * Lookup and return the information necessary to access a container.
   * @arg name {String} name of the container, e.g. `'_public'`
   * @returns {Promise<MutableData>} the MutableData behind it
   */
  getContainer(name: String): Promise<MutableData>;

  /**
   * Create a new authenticated or unregistered session using the provided IPC response.
   * @arg {String} uri the IPC response string given
   * @returns {Promise<SAFEApp>} the given app instance with a newly setup and
   *          authenticated session.
   */
  loginFromUri(uri: String): Promise<SAFEApp>;

  /**
   * *ONLY AVAILALBE IF RUN in NODE_ENV='development' || 'testing'*
   *
   * Generate a _locally_ registered App with the given permissions, or
   * a local unregistered App if permissions is `null`.
   * @returns {Promise<SAFEApp>} the locally registered/unregistered App instance
   */
  loginForTest(): Promise<SAFEApp>;

  /**
   * *ONLY AVAILALBE IF RUN in NODE_ENV='development' || 'testing'*
   *
   * Simulates a network disconnection event. This can be used to
   * test any logic to be executed by an application when a network
   * diconnection notification is received.
   */
  simulateNetworkDisconnect(): void;

}

/**
 * Holds the reference to a Cipher Options,
 * either PlainText, Symmetric or Asymmetric
 */
declare class CipherOpt {
  /**
   * Holds the reference to a Cipher Options,
   * either PlainText, Symmetric or Asymmetric
   */
  constructor();

}

/**
 * Provide the Cipher Opt API
 */
declare class CipherOptInterface {
  /**
   * Provide the Cipher Opt API
   */
  constructor();

  /**
   * Create a PlainText Cipher Opt
   * @returns {CipherOpt}
   */
  newPlainText(): CipherOpt;

  /**
   * Create a new Symmetric Cipher
   * @returns {CipherOpt}
   */
  newSymmetric(): CipherOpt;

  /**
   * Create a new Asymmetric Cipher for the given public encryption key
   * @param {PubEncKey} pubEncKey
   * @returns {CipherOpt}
   */
  newAsymmetric(pubEncKey: PubEncKey): CipherOpt;

}

/**
 * Holds the public part of an encryption key
 */
declare class PubEncKey {
  /**
   * Holds the public part of an encryption key
   */
  constructor();

  /**
   * generate raw string copy of public encryption key
   * @returns {Promise<Buffer>}
   */
  getRaw(): Promise<Buffer>;

  /**
   * Encrypt the input (buffer or string) using the private and public key with a seal
   * @returns {Promise<Buffer>} Ciphertext
   */
  encryptSealed(): Promise<Buffer>;

  /**
   * Decrypt the given cipher text (buffer or string) using this public
   * encryption key and the given secret key
   *
   * @arg {Buffer} cipher to decrypt
   * @arg {SecEncKey} secretEncKey secret encryption key
   * @returns {Promise<Buffer>} plain text
   */
  decrypt(cipher: Buffer, secretEncKey: SecEncKey): Promise<Buffer>;

  /**
   * Encrypt the input (buffer or string) using this public encryption key
   * and the given secret key.
   *
   * @param {Buffer} data to be encrypted
   * @param {SecEncKey} secretEncKey secret encrpytion key
   * @returns {Promise<Buffer>} cipher text
   */
  encrypt(data: Buffer, secretEncKey: SecEncKey): Promise<Buffer>;

}

/**
 * Holds the secret part of an encryption key
 */
declare class SecEncKey {
  /**
   * Holds the secret part of an encryption key
   */
  constructor();

  /**
   * generate raw string copy of secret encryption key
   * @returns {Promise<Buffer>}
   */
  getRaw(): Promise<Buffer>;

  /**
   * Decrypt the given cipher text (buffer or string) using this secret
   * encryption key and the given public key
   *
   * An example use case for this method is if you have received messages from multiple
   * senders, you may fetch your secret key once, then iterate over the messages along
   * with passing associated public encryption key to decrypt each message.
   *
   * @arg {Buffer} cipher to decrypt
   * @arg {PubEncKey} publicEncKey public encryption key
   * @returns {Promise<Buffer>} plain text
   */
  decrypt(cipher: Buffer, publicEncKey: PubEncKey): Promise<Buffer>;

  /**
   * Encrypt the input (buffer or string) using this secret encryption key
   * and the recipient's public key
   *
   * An example use case for this method is if you have multiple intended recipients.
   * You can fetch your secret key once, then use this method to iterate over
   * recipient public encryption keys, encrypting data for each key.
   *
   * @param {Buffer} data to be encrypted
   * @param {PubEncKey} recipientPubKey recipient's public encryption key
   * @returns {Promise<Buffer>} cipher text
   */
  encrypt(data: Buffer, recipientPubKey: PubEncKey): Promise<Buffer>;

}

/**
 * Holds an asymmetric encryption keypair
 */
declare class EncKeyPair {
  /**
   * Holds an asymmetric encryption keypair
   */
  constructor();

  /**
   * get the Public Encryption key instance of this keypair
   * @returns {PubEncKey}
   */
  pubEncKey: any;

  /**
   * get the Secrect Encryption key instance of this keypair
   * @returns {secEncKey}
   */
  secEncKey: any;

  /**
   * Decrypt the given cipher text with a seal (buffer or string) using
   * this encryption key pair
   * @returns {Promise<Buffer>} plain text
   */
  decryptSealed(): Promise<Buffer>;

}

/**
 * Holds the public part of a sign key
 */
declare class PubSignKey {
  /**
   * Holds the public part of a sign key
   */
  constructor();

  /**
   * generate raw string copy of public sign key
   * @returns {Promise<Buffer>}
   */
  getRaw(): Promise<Buffer>;

  /**
   * Verify the given signed data (buffer or string) using the public sign key
   * @param {Buffer} data to verify signature
   * @returns {Promise<Buffer>}
   */
  verify(data: Buffer): Promise<Buffer>;

}

/**
 * Holds the secret part of a sign key
 */
declare class SecSignKey {
  /**
   * Holds the secret part of a sign key
   */
  constructor();

  /**
   * generate raw string copy of secret sign key
   * @returns {Promise<Buffer>}
   */
  getRaw(): Promise<Buffer>;

  /**
   * Sign the given data (buffer or string) using the secret sign key
   * @param {Buffer} data to sign
   * @returns {Promise<Buffer>} signed data
   */
  sign(data: Buffer): Promise<Buffer>;

}

/**
 * Holds a sign key pair
 */
declare class SignKeyPair {
  /**
   * Holds a sign key pair
   */
  constructor();

  /**
   * get the public sign key instance of this key pair
   * @returns {PubSignKey}
   */
  pubSignKey: any;

  /**
   * get the secrect sign key instance of this key pair
   * @returns {SecSignKey}
   */
  secSignKey: any;

}

/**
 * Encryption functionality for the app
 *
 * Access it through your {SAFEApp} instance under `app.crypto`
 */
declare class CryptoInterface {
  /**
   * Encryption functionality for the app
   *
   * Access it through your {SAFEApp} instance under `app.crypto`
   */
  constructor(app: SAFEApp);

  /**
   * Get the public signing key of this session
   * @returns {Promise<PubSignKey>}
   */
  getAppPubSignKey(): Promise<PubSignKey>;

  /**
   * Get the public encryption key of this session
   * @returns {Promise<PubEncKey>}
   */
  getAppPubEncKey(): Promise<PubEncKey>;

  /**
   * Generate a new Asymmetric Encryption Key Pair
   * @returns {Promise<EncKeyPair>}
   */
  generateEncKeyPair(): Promise<EncKeyPair>;

  /**
   * Generate a new Sign Key Pair (public & private keys).
   * @returns {Promise<SignKeyPair>}
   */
  generateSignKeyPair(): Promise<SignKeyPair>;

  /**
   * Generate a new Asymmetric Encryption Key Pair from raw secret and public keys
   * @returns {Promise<EncKeyPair>}
   */
  generateEncKeyPairFromRaw(): Promise<EncKeyPair>;

  /**
   * Generate a new Sign Key Pair from raw secret and public keys
   * @returns {Promise<SignKeyPair>}
   */
  generateSignKeyPairFromRaw(): Promise<SignKeyPair>;

  /**
   * Interprete the Public Sign Key from a given raw string
   * @param {String} raw public sign key raw bytes as string
   * @returns {Promise<PubSignKey>}
   */
  pubSignKeyFromRaw(raw: String): Promise<PubSignKey>;

  /**
   * Interprete the Secret Sign Key from a given raw string
   * @param {String} raw secret sign key raw bytes as string
   * @returns {Promise<SecSignKey>}
   */
  secSignKeyFromRaw(raw: String): Promise<SecSignKey>;

  /**
   * Interprete the public encryption Key from a given raw string
   * @arg {String} raw public encryption key raw bytes as string
   * @returns {Promise<PubEncKey>}
   */
  pubEncKeyFromRaw(raw: String): Promise<PubEncKey>;

  /**
   * Interprete the secret encryption Key from a given raw string
   * @arg {String} raw secret encryption key raw bytes as string
   * @returns {Promise<SecEncKey>}
   */
  secEncKeyFromRaw(raw: String): Promise<SecEncKey>;

}

/**
 * Emulations are abstraction helpers on top of MData
 * @typedef {NFS} Emulation
 */
type Emulation = NFS;

/**
 * A NFS-style NfsFile
 *
 * _Note_: As this application layer, the network does not check any
 * of the metadata provided.
 */
declare class NfsFile {
  /**
   * A NFS-style NfsFile
   *
   * _Note_: As this application layer, the network does not check any
   * of the metadata provided.
   */
  constructor(ref: Object);

  /**
   * The dataMapName to read the immutable data at
   * @returns {Buffer} XoR-name
   */
  dataMapName: any;

  /**
   *
   * @returns {Buffer} user_metadata
   */
  userMetadata: any;

  /**
   * When was this created? in UTC.
   * @return {Date}
   */
  created: any;

  /**
   * When was this last modified? in UTC.
   * @return {Date}
   */
  modified: any;

  /**
   * Get file size
   * @returns {Promise<Number>}
   */
  size(): Promise<Number>;

  /**
   * Read the file.
   * SafeNodeApp.CONSTANTS.NFS_FILE_START and SafeNodeApp.CONSTANTS.NFS_FILE_END may be used
   * to read the entire content of the file. These constants are
   * exposed by the safe-app-nodejs package.
   * @param {Number|SafeNodeApp.CONSTANTS.NFS_FILE_START} position
   * @param {Number|SafeNodeApp.CONSTANTS.NFS_FILE_END} len
   * @returns {Promise<[Buffer, number]>}
   */
  read(position: (Number | SafeNodeApp.CONSTANTS.MD_ENTRIES_EMPTY), len: (Number | SafeNodeApp.CONSTANTS.NFS_FILE_END)): Promise<[Buffer, number]>;

  /**
   * Write file
   * @param {Buffer|String} content
   * @returns {Promise}
   */
  write(content: (Buffer | String)): Promise<void>;

  /**
   * Close file
   * @returns {Promise}
   */
  close(): Promise<void>;

  /**
   * Which version was this? Equals the underlying MutableData's entry version.
   * @return {Number}
   */
  version: any;

}

/**
 * NFS Emulation on top of an MData
 */
declare class NFS {
  /**
   * NFS Emulation on top of an MData
   */
  constructor(mData: MutableData);

  /**
   * Helper function to create and save file to the network
   * @param {String|Buffer} content - file contents
   * @returns {NfsFile} a newly created file
   */
  create(content: (String | Buffer)): NfsFile;

  /**
   * Find the file of the given filename (aka keyName in the MutableData)
   * @param {String} fileName - the path/file name
   * @returns {Promise<NfsFile>} - the file found for that path
   */
  fetch(fileName: String): Promise<NfsFile>;

  /**
   * Insert the given file into the underlying MutableData, directly commit
   * to the network.
   * @param {(String|Buffer)} fileName - the path to store the file under
   * @param {NfsFile} file - the file to serialise and store
   * @param {String|Buffer} userMetadata
   * @returns {Promise<NfsFile>} - the same file
   */
  insert(fileName: (String | Buffer), file: NfsFile, userMetadata: (String | Buffer)): Promise<NfsFile>;

  /**
   * Replace a path with a new file. Directly commit to the network.
   * @param {(String|Buffer)} fileName - the path to store the file under
   * @param {NfsFile} file - the file to serialise and store
   * @param {Number} version - the version successor number, to ensure you
  are overwriting the right one
   * @param {String|Buffer} userMetadata - optional parameter for updating user metadata
   * @returns {Promise<NfsFile>} - the same file
   */
  update(fileName: (String | Buffer), file: NfsFile, version: Number, userMetadata: (String | Buffer)): Promise<NfsFile>;

  /**
   * Delete a file from path. Directly commit to the network.
   * @param {(String|Buffer)} fileName
   * @param {Number} version
   * @returns {Promise}
   */
  delete(fileName: (String | Buffer), version: Number): Promise<void>;

  /**
   * Open a file for reading or writing.
   *
   * Open modes (these constants are exported by the safe-app-nodejs package):
   *
   * SafeNodeApp.CONSTANTS.NFS_FILE_MODE_OVERWRITE: Replaces the entire content of the file when writing data.
   *
   * SafeNodeApp.CONSTANTS.NFS_FILE_MODE_APPEND: Appends to existing data in the file.
   *
   * SafeNodeApp.CONSTANTS.NFS_FILE_MODE_READ: Open file to read.
   *
   * @param {NfsFile} file
   * @param {Number|SafeNodeApp.CONSTANTS.NFS_FILE_MODE_OVERWRITE|
   *         SafeNodeApp.CONSTANTS.NFS_FILE_MODE_APPEND|
   *         SafeNodeApp.CONSTANTS.NFS_FILE_MODE_READ} [openMode=SafeNodeApp.CONSTANTS.NFS_FILE_MODE_OVERWRITE]
   * @returns {Promise<NfsFile>}
   */
  open(file: NfsFile, openMode?: (Number | SafeNodeApp.CONSTANTS.NFS_FILE_MODE_OVERWRITE | SafeNodeApp.CONSTANTS.NFS_FILE_MODE_APPEND | SafeNodeApp.CONSTANTS.NFS_FILE_MODE_READ)): Promise<NfsFile>;

}

/**
 * Holds the connection to read an existing ImmutableData
 */
declare class Reader {
  /**
   * Holds the connection to read an existing ImmutableData
   */
  constructor();

  /**
   * Read the given amount of bytes from the network
   * @param {Object=} options
   * @param {Number} [options.offset=0] start position
   * @param {Number} [options.end=size] end position or end of data
   */
  read(options?: { offset: Number, end: Number }): void;

  /**
   * The size of the immutable data on the network
   * @returns {Promise<Number>} length in bytes
   */
  size(): Promise<Number>;
}

/**
 * Holds an Immutable Data Writer
 *
 * @example // write new data to the network
 * app.immutableData.create()
 *  .then((writer) => writer.write("some string\n")
 *    .then(() => writer.write("second string"))
 *    .then(() => app.cipherOpt.newPlainText())
 *    .then((cipher) => writer.close(cipher))
 *  ).then((address) => app.immutableData.fetch(address))
 *  .then((reader) => reader.read())
 *  .then((payload) => {
 *    console.log("Data read from ImmutableData: ", payload.toString());
 *  })
 *
 */
declare class Writer {
  /**
   * Holds an Immutable Data Writer
   *
   * @example // write new data to the network
   * app.immutableData.create()
   *  .then((writer) => writer.write("some string\n")
   *    .then(() => writer.write("second string"))
   *    .then(() => app.cipherOpt.newPlainText())
   *    .then((cipher) => writer.close(cipher))
   *  ).then((address) => app.immutableData.fetch(address))
   *  .then((reader) => reader.read())
   *  .then((payload) => {
   *    console.log("Data read from ImmutableData: ", payload.toString());
   *  })
   *
   */
  constructor();

  /**
   * Append the given data to immutable Data.
   *
   * @param {String|Buffer} data The string or buffer to write
   * @returns {Promise<void>}
   */
  write(data: (String | Buffer)): Promise<void>;

  /**
   * Close and write the immutable Data to the network.
   *
   * @param {CipherOpt} cipherOpt the Cipher Opt to encrypt data with
   * @returns {Promise<String>} the address to the data once written to the network
   */
  close(cipherOpt: CipherOpt): Promise<String>;
}

/**
 * Interact with Immutable Data of the Network through this Interface.
 *
 * Access it through your {SAFEApp} instance under `app.immutableData`
 */
declare class ImmutableDataInterface {
  /**
   * Interact with Immutable Data of the Network through this Interface.
   *
   * Access it through your {SAFEApp} instance under `app.immutableData`
   */
  constructor(app: SAFEApp);

  /**
   * Create a new ImmutableDataInterface
   * @returns {Promise<Writer>}
   */
  create(): Promise<Writer>;

  /**
   * Look up an existing Immutable Data for the given address
   * @param {Buffer} address the XorName on the network
   * @returns {Promise<Reader>}
   */
  fetch(address: Buffer): Promise<Reader>;

}

/**
 * Holds the permissions of a MutableData object
 */
declare class Permissions {
  /**
   * Holds the permissions of a MutableData object
   */
  constructor();

  /**
   * Total number of permission entries
   * @returns {Promise<Number>} number of entries
   */
  len(): Promise<Number>;

  /**
   * Lookup the permissions of a specifc key
   *
   * @param {PubSignKey|SafeNodeApp.CONSTANTS.USER_ANYONE} [signKey=SafeNodeApp.CONSTANTS.USER_ANYONE] the key to lookup for
   * @returns {Promise<Object>} the permission set for that key
   */
  getPermissionSet(signKey?: (PubSignKey | SafeNodeApp.CONSTANTS.USER_ANYONE)): Promise<Object>;

  /**
   * Insert a new permission set mapped to a specifc key. Directly commits
   * to the network.
   * Requires 'ManagePermissions'-Permission for the app.
   * @param {PubSignKey|SafeNodeApp.CONSTANTS.USER_ANYONE} [signKey=SafeNodeApp.CONSTANTS.USER_ANYONE] the key to map to
   * @param {Object} permissionSet the permission set to insert
   * @returns {Promise} once finished
   */
  insertPermissionSet(signKey: (PubSignKey | SafeNodeApp.CONSTANTS.USER_ANYONE), permissionSet: Object): Promise<void>;

  /**
   * Return the list of all associated permission sets.
   * @returns {Promise<Array>} the list of permission sets
   */
  listPermissionSets(): Promise<Array<any>>;

}

/**
 * Holds a mutations to be done to the entries within one
 * transaction on the network.
 *
 * You need this whenever you want to change the content of
 * the entries.
 *
 * @example // Mutate a range of Entries
 *
 * app.mutableData.newPublic(somename, tagtype)
 *  .then((mData) => mData.getEntries()
 *   .then((entries) => entries.mutate()
 *     .then((m) => m.insert('key', 'value')
 *       // this is where all mutations are recorded
 *       .then(() => mData.applyEntriesMutation(m))
 *     )))
 */
declare class EntryMutationTransaction {
  /**
   * Holds a mutations to be done to the entries within one
   * transaction on the network.
   *
   * You need this whenever you want to change the content of
   * the entries.
   *
   * @example // Mutate a range of Entries
   *
   * app.mutableData.newPublic(somename, tagtype)
   *  .then((mData) => mData.getEntries()
   *   .then((entries) => entries.mutate()
   *     .then((m) => m.insert('key', 'value')
   *       // this is where all mutations are recorded
   *       .then(() => mData.applyEntriesMutation(m))
   *     )))
   */
  constructor();

  /**
   * Store a new `Insert`-Action in the transaction to store a new entry.
   *
   * @param {(String|Buffer)} keyName the key you want to insert
   * @param {(String|Buffer)} value the value you want to insert
   * @returns {Promise} resolves once the storing is done
   */
  insert(keyName: (String | Buffer), value: (String | Buffer)): Promise<void>;

  /**
   * Store a new `Delete`-Action in the transaction to delete an existing entry.
   *
   * @param {(String|Buffer)} keyName the key you want to delete
   * @param {Number} version the version successor, to confirm you are
   *        actually asking for the right version
   * @returns {Promise} resolves once the storing is done
   */
  delete(keyName: (String | Buffer), version: Number): Promise<void>;

  /**
   * Store a `Update`-Action in the transaction to update an existing entry.
   *
   * @param {(String|Buffer)} keyName the key for the entry you want to update
   * @param {(String|Buffer)} value the value to upate to
   * @param {Number} version - the version successor, to confirm you are
   *        actually asking for the right version
   * @returns {Promise} resolves once the storing is done
   */
  update(keyName: (String | Buffer), value: (String | Buffer), version: Number): Promise<void>;

}

/**
 * Represent the Entries of a MutableData network object
 */
declare class Entries {
  /**
   * Represent the Entries of a MutableData network object
   */
  constructor();

  /**
   * Get the total number of entries in the MutableData
   * @returns {Promise<Number>} number of entries
   */
  len(): Promise<Number>;

  /**
   * Look up the value of a specific key
   *
   * @param {String} keyName the key to lookup
   * @returns {Promise<ValueVersion>} the entry's value and the current version
   */
  get(keyName: String): Promise<ValueVersion>;

  /**
   * Get a list with the entries contained in this MutableData
   * @returns {Promise<Array<any>>} the entries list
   */
  listEntries(): Promise<Array<any>>;

  /**
   * Insert a new entry. Once you call `MutableData.put` with this entry,
   * it will fail if the entry already exists or the current app doesn't have the
   * permissions to edit that mutable data.
   *
   *
   * @param {(String|Buffer)} keyName the key you want store the data under
   * @param {(String|Buffer)} value the data you want to store
   * @returns {Promise} resolves once storing is done
   */
  insert(keyName: (String | Buffer), value: (String | Buffer)): Promise<void>;

  /**
   * Create a new mutation transaction for the entries
   * @return {Promise<EntryMutationTransaction>} the mutation transaction object
   */
  mutate(): Promise<EntryMutationTransaction>;

}

/**
 * @typedef {Object} ValueVersion
 * @param {Buffer} buf the buffer with the value
 * @param {Number} version the version
 * Holds the informatation of a value of a MutableData
 */
type ValueVersion = Object;

/**
 * @typedef {Object} NameAndTag
 * @param {Buffer} name - the XoR-name/address on the network
 * @param {Number} typeTag - the type tag
 */
type NameAndTag = Object;

/**
 * Holds the reference to a MutableData
 */
declare class MutableData {
  /**
   * Holds the reference to a MutableData
   */
  constructor();

  /**
   * Easily set up a newly (not yet created) MutableData with
   * the app having full-access permissions (and no other).
   * The name and description parameters are metadata for the MutableData which
   * can be used to identify what this MutablaData contains.
   * The metadata is particularly used by the Authenticator when another
   * application has requested mutation permissions on this MutableData,
   * so the user can make a better decision to either allow or deny such a
   * request based on this information.
   *
   * @param {Object} data a key-value payload it should
   *        create the data with
   * @param {(String|Buffer)} name a descriptive name for the MutableData
   * @param {(String|Buffer)} description a detailed description for the MutableData content
   *
   * @returns {Promise<MutableData>} self
   * @example
   * app.mutableData.newRandomPublic(tagtype)
   *   .then((md) => md.quickSetup({
   *        key1: 'value1',
   *        key2: 'value2'
   *      }, 'My MutableData', 'To store my app\'s data'))
   */
  quickSetup(data: Object, name: (String | Buffer), description: (String | Buffer)): Promise<MutableData>;

  /**
   * Set the metadata information in the MutableData. Note this can be used
   * only if the MutableData was already committed to the network, .i.e either
   * with `put`, with `quickSetup`, or if it is an already existing MutableData
   * just fetched from the network.
   * The metadata is particularly used by the Authenticator when another
   * application has requested mutation permissions on this MutableData,
   * displaying this information to the user, so the user can make a better
   * decision to either allow or deny such a request based on it.
   *
   * @param {(String|Buffer)} name a descriptive name for the MutableData
   * @param {(String|Buffer)} description a detailed description for the MutableData content
   *
   * @returns {Promise} resolves once finished
   */
  setMetadata(name: (String | Buffer), description: (String | Buffer)): Promise<void>;

  /**
   * Encrypt the entry key provided as parameter with the encryption key
   * contained in a Private MutableData. If the MutableData is Public, the same
   * (and unencrypted) value is returned.
   *
   * @param {(String|Buffer)} key the key you want to encrypt
   * @returns {Promise<Buffer>} the encrypted entry key
   */
  encryptKey(key: (String | Buffer)): Promise<Buffer>;

  /**
   * Encrypt the entry value provided as parameter with the encryption key
   * contained in a Private MutableData. If the MutableData is Public, the same
   * (and unencrypted) value is returned.
   *
   * @param {(String|Buffer)} value the data you want to encrypt
   * @returns {Promise<Buffer>} the encrypted entry value
   */
  encryptValue(value: (String | Buffer)): Promise<Buffer>;

  /**
   * Decrypt the entry key/value provided as parameter with the encryption key
   * contained in a Private MutableData.
   *
   * @param {(String|Buffer)} value the data you want to decrypt
   * @returns {Promise<Buffer>} the decrypted value
   */
  decrypt(value: (String | Buffer)): Promise<Buffer>;

  /**
   * Look up the name and tag of the MutableData as required to look it
   * up on the network.
   *
   * @returns {Promise<NameAndTag>} the XoR-name and type tag
   */
  getNameAndTag(): Promise<NameAndTag>;

  /**
   * Look up the mutable data object version on the network
   *
   * @returns {Promise<Number>} current version
   */
  getVersion(): Promise<Number>;

  /**
   * Look up the value of a specific key
   *
   * @returns {Promise<ValueVersion>} the entry value and its current version
   */
  get(): Promise<ValueVersion>;

  /**
   * Commit this MutableData to the network.
   * @param {Permission|SafeNodeApp.CONSTANTS.MD_PERMISSION_EMPTY} permissions
   * the permissions to create the mutable data with
   * @param {Entries|SafeNodeApp.CONSTANTS.MD_ENTRIES_EMPTY} entries
   * data entries to create the mutable data with
   * @returns {Promise}
   */
  put(permissions: (Permissions | SafeNodeApp.CONSTANTS.MD_PERMISSION_EMPTY), entries: (Entries | SafeNodeApp.CONSTANTS.MD_ENTRIES_EMPTY)): Promise<void>;

  /**
   * Get a Handle to the entries associated with this MutableData
   * @returns {Promise<(Entries)>} the entries representation object
   */
  getEntries(): Promise<(Entries)>;

  /**
   * Get a list with the keys contained in this MutableData
   * @returns {Promise<Array<any>>} the keys list
   */
  getKeys(): Promise<Array<any>>;

  /**
   * Get the list of values contained in this MutableData
   * @returns {Promise<Array<any>>} the list of values
   */
  getValues(): Promise<Array<any>>;

  /**
   * Get a Handle to the permissions associated with this mutableData
   * @returns {Promise<(Permissions)>} the permissions representation object
   */
  getPermissions(): Promise<(Permissions)>;

  /**
   * Get a Handle to the permissions associated with this MutableData for
   * a specifc key
   * @param {PubSignKey|SafeNodeApp.CONSTANTS.USER_ANYONE} [signKey=SafeNodeApp.CONSTANTS.USER_ANYONE] the key to look up
   * @returns {Promise<(Permissions)>} the permissions set associated to the key
   */
  getUserPermissions(signKey: (PubSignKey | SafeNodeApp.CONSTANTS.USER_ANYONE)): Promise<(Permissions)>;

  /**
   * Delete the permissions of a specifc key. Directly commits to the network.
   * Requires 'ManagePermissions'-Permission for the app.
   * @param {PubSignKey|SafeNodeApp.CONSTANTS.USER_ANYONE} [signKey=SafeNodeApp.CONSTANTS.USER_ANYONE] the key to lookup for
   * @param {Number} version the version successor, to confirm you are
   *        actually asking for the right one
   * @returns {Promise} once finished
   */
  delUserPermissions(signKey: (PubSignKey | SafeNodeApp.CONSTANTS.USER_ANYONE), version: Number): Promise<void>;

  /**
   * Set the permissions of a specifc key. Directly commits to the network.
   * Requires 'ManagePermissions'-Permission for the app.
   * @param {PubSignKey|SafeNodeApp.CONSTANTS.USER_ANYONE} [signKey=SafeNodeApp.CONSTANTS.USER_ANYONE] the key to lookup for
   * @param {PermissionSet} permissionSet the permission set to set to
   * @param {Number} version the version successor, to confirm you are
   *        actually asking for the right one
   * @returns {Promise} resolves once finished
   */
  setUserPermissions(signKey: (PubSignKey | SafeNodeApp.CONSTANTS.USER_ANYONE), permissionSet: any, version: Number): Promise<void>;

  /**
   * Commit the transaction to the network
   * @param {EntryMutationTransaction} mutations the Mutations you want to apply
   * @return {Promise} resolves once finished
   */
  applyEntriesMutation(mutations: EntryMutationTransaction): Promise<void>;

  /**
   * Serialise the current MutableData
   * @returns {Promise<(String)>} the serialilsed version of the MutableData
   */
  serialise(): Promise<(String)>;

  /**
   * Get serialised size of current MutableData
   * @returns {Promise<(Number)>} the serialilsed size of the MutableData
   */
  getSerialisedSize(): Promise<(Number)>;

  /**
   * Wrap this MutableData into a known abstraction. Currently only known: `NFS`
   * @param {String} eml - name of the emulation
   * @returns {Emulation} the Emulation you are asking for
   */
  emulateAs(eml: String): Emulation;

}

/**
 * Provide the MutableData API for the session.
 *
 * Access via `mutableData` on your app Instance.
 *
 * @example // using mutable Data
 * app.mutableData.newRandomPublic(15001)
 *   // set it up with starting data
 *   .then((mdata) => mdata.quickSetup({keyA: 'input value'})
 *    .then(() => mdata.getNameAndTag())) // return name and tag
 *
 * // now read using name and tag
 * .then((ref) => app.mutableData.newPublic(ref.name, ref.tag)
 *   .then((mdata) => mdata.get('keyA').then((val) => {
 *     should(val.buf.toString()).equal('input value');
 *   })))
 */
declare class MutableDataInterface {
  /**
   * Provide the MutableData API for the session.
   *
   * Access via `mutableData` on your app Instance.
   *
   * @example // using mutable Data
   * app.mutableData.newRandomPublic(15001)
   *   // set it up with starting data
   *   .then((mdata) => mdata.quickSetup({keyA: 'input value'})
   *    .then(() => mdata.getNameAndTag())) // return name and tag
   *
   * // now read using name and tag
   * .then((ref) => app.mutableData.newPublic(ref.name, ref.tag)
   *   .then((mdata) => mdata.get('keyA').then((val) => {
   *     should(val.buf.toString()).equal('input value');
   *   })))
   */
  constructor(app: SAFEApp);

  /**
   * Create a new mutuable data at a random address with private
   * access.
   * @param {Number} typeTag the typeTag to use
   * @returns {Promise<MutableData>}
   */
  newRandomPrivate(typeTag: Number): Promise<MutableData>;

  /**
   * Create a new mutuable data at a random address with public
   * access.
   * @param {Number} typeTag - the typeTag to use
   * @returns {Promise<MutableData>}
   */
  newRandomPublic(typeTag: Number): Promise<MutableData>;

  /**
   * Initiate a mutuable data at the given address with private
   * access.
   * @param {Buffer|String} name
   * @param {Number} typeTag - the typeTag to use
   * @param {Buffer|String} secKey
   * @param {Buffer|String} nonce
   * @returns {Promise<MutableData>}
   */
  newPrivate(name: (Buffer | String), typeTag: Number, secKey: (Buffer | String), nonce: (Buffer | String)): Promise<MutableData>;

  /**
   * Initiate a mutuable data at the given address with public
   * access.
   * @param {Buffer|String}
   * @param {Number} typeTag the typeTag to use
   * @returns {Promise<MutableData>}
   */
  newPublic(name: (Buffer | String), typeTag: Number): Promise<MutableData>;

  /**
   * Create a new Permissions object.
   * @returns {Promise<Permissions>}
   */
  newPermissions(): Promise<Permissions>;

  /**
   * Create a new EntryMutationTransaction object.
   * @returns {Promise<EntryMutationTransaction>}
   */
  newMutation(): Promise<EntryMutationTransaction>;

  /**
   * Create a new Entries object.
   * @returns {Promise<Entries>}
   */
  newEntries(): Promise<Entries>;

  /**
   * Create a new Mutuable Data object from its serial
   * @returns {Promise<MutableData>}
   */
  fromSerial(): Promise<MutableData>;

}

/**
 * Validates appInfo and properly handles error
 */
declare function validateAppInfo(): void;

/**
 * Init logging on the underlying library only if it wasn't done already
 */
declare function initLogging(): void;

/**
 * Set additional search path for the config files if it was requested in
 * the options. E.g. log.toml and crust.config files will be search
 * in this additional search path.
 */
declare function setSearchPath(): void;

/**
 * Holds one sessions with the network and is the primary interface to interact
 * with the network. As such it also provides all API-Providers connected through
 * this session.
 */
declare class SAFEApp {
  /**
   * Holds one sessions with the network and is the primary interface to interact
   * with the network. As such it also provides all API-Providers connected through
   * this session.
   */
  constructor(appInfo: AppInfo, networkStateCallBack?: (() => any), initilalisation?: InitOptions);

  /**
   * get the AuthInterface instance connected to this session
   * @returns {AuthInterface}
   */
  auth: any;

  /**
   * get the Crypto instance connected to this session
   * @returns {CryptoInterface}
   */
  crypto: any;

  /**
   * get the CipherOptInterface instance connected to this session
   * @returns {CipherOptInterface}
   */
  cipherOpt: any;

  /**
   * get the ImmutableDataInterface instance connected to this session
   * @returns {ImmutableDataInterface}
   */
  immutableData: any;

  /**
   * get the MutableDataInterface instance connected to this session
   * @returns {MutableDataInterface}
   */
  mutableData: any;

  /**
   * Returns true if current network connection state is INIT.
   * This is state means the library has been initialised but there is no
   * connection made with the network yet.
   *
   * @returns {Boolean}
   */
  isNetStateInit(): Boolean;

  /**
   * Returns true if current network connection state is CONNECTED.
   *
   * @returns {Boolean}
   */
  isNetStateConnected(): Boolean;

  /**
   * Returns true if current network connection state is DISCONNECTED.
   *
   * @returns {Boolean}
   */
  isNetStateDisconnected(): Boolean;

  /**
   * The current appInfo
   */
  appInfo: any;

  /**
   * Returns account information, e.g. number of mutations done and available.
   *
   * @returns {Promise<AccountInfo>}
   */
  getAccountInfo(): Promise<AccountInfo>;

  /**
   * Create a SAFEApp and try to login it through the `authUri`
   *
   * @param {AppInfo} appInfo - the AppInfo
   * @param {String} authUri - URI containing the authentication info
   * @param {Function} [networkStateCallBack=null] optional callback function to receive network state updates
   * @param {InitOptions}  initialisation options
   * @returns {Promise<SAFEApp>} authenticated and connected SAFEApp
   */
  static fromAuthUri(appInfo: AppInfo, authUri: String, networkStateCallBack?: (() => any), initialisation?: InitOptions): Promise<SAFEApp>;

  /**
   * Returns the name of the app's own container.
   *
   * @returns {Promise<String>}
   */
  getOwnContainerName(): Promise<String>;

  /**
   * Reconnect to the metwork
   * Must be invoked when the client decides to connect back after the connection was lost.
   */
  reconnect(): void;

  /**
   * Resets the object cache kept by the underlyging library.
   */
  clearObjectCache(): void;

  /**
   * Retuns true if the underlyging library was compiled against mock-routing.
   */
  isMockBuild(): void;
}

/**
 * @typedef {Object} AccountInfo
 * Holds the information about the account.
 * @param {Number} mutations_done - number of mutations performed
 * with this account
 * @param {Number} mutations_available - number of remaining mutations
 * allowed for this account
 */
type AccountInfo = Object;

interface IERR_NO_SUCH_DATA {
  code: number;
  msg: string;
}

/**
 * @name ERR_NO_SUCH_DATA
 * @type {object}
 * @description Thrown natively when data not found on network.
 * @property {number} code -103
 * @property {string} msg
 */
declare var ERR_NO_SUCH_DATA: IERR_NO_SUCH_DATA;

interface IERR_NO_SUCH_ENTRY {
  code: number;
  msg: string;
}

/**
 * @name ERR_NO_SUCH_ENTRY
 * @type {object}
 * @description Thrown natively when entry on found in MutableData.
 * @property {number} code -106
 * @property {string} msg
 */
declare var ERR_NO_SUCH_ENTRY: IERR_NO_SUCH_ENTRY;

interface IERR_FILE_NOT_FOUND {
  code: number;
  msg: string;
}

/**
 * @name ERR_FILE_NOT_FOUND
 * @type {object}
 * @description Thrown natively when NFS-style file not found.
 * @property {number} code -301
 * @property {string} msg
 */
declare var ERR_FILE_NOT_FOUND: IERR_FILE_NOT_FOUND;

interface IINVALID_BYTE_RANGE {
  code: number;
  msg: string;
}

/**
 * @name INVALID_BYTE_RANGE
 * @type {object}
 * @description Thrown natively when attempting to fetch partial
 * byte range of NFS-style file that is not within the total byte range.
 * For example, this error is thrown if a file is 10 bytes long,
 * however a byte range of 20 is requested.
 * @property {number} code -302
 * @property {string} msg
 */
declare var INVALID_BYTE_RANGE: IINVALID_BYTE_RANGE;

interface IFAILED_TO_LOAD_LIB {
  code: number;
  msg: (() => any);
}

/**
 * @name FAILED_TO_LOAD_LIB
 * @type {object}
 * @description Thrown when a native library fails to load and which library.
 * @property {number} code 1000
 * @property {function} msg
 */
declare var FAILED_TO_LOAD_LIB: IFAILED_TO_LOAD_LIB;

interface ISETUP_INCOMPLETE {
  code: number;
  msg: string;
}

/**
 * @name SETUP_INCOMPLETE
 * @type {object}
 * @description Informs that app is not yet connected to network.
 * @property {number} code 1001
 * @property {string} msg
 */
declare var SETUP_INCOMPLETE: ISETUP_INCOMPLETE;

interface IMALFORMED_APP_INFO {
  code: number;
  msg: string;
}

/**
 * @name MALFORMED_APP_INFO
 * @type {object}
 * @description Informs when app info provided during initialisation is invalid.
 * @property {number} code 1002
 * @property {string} msg
 */
declare var MALFORMED_APP_INFO: IMALFORMED_APP_INFO;

interface IMISSING_PERMS_ARRAY {
  code: number;
  msg: string;
}

/**
 * @name MISSING_PERMS_ARRAY
 * @type {object}
 * @description Argument should be an array object.
 * @property {number} code 1003
 * @property {string} msg
 */
declare var MISSING_PERMS_ARRAY: IMISSING_PERMS_ARRAY;

interface IINVALID_SHARE_MD_PERMISSION {
  code: number;
  msg: (() => any);
}

/**
 * @name INVALID_SHARE_MD_PERMISSION
 * @type {object}
 * @description Informs of a specific object in a share MData permissions array that is malformed.
 * @property {number} code 1004
 * @property {function} msg
 */
declare var INVALID_SHARE_MD_PERMISSION: IINVALID_SHARE_MD_PERMISSION;

interface IINVALID_PERMS_ARRAY {
  code: number;
  msg: string;
}

/**
 * @name INVALID_PERMS_ARRAY
 * @type {object}
 * @description Thrown when share MD permissions is not an array.
 * @property {number} code 1005
 * @property {string} msg
 */
declare var INVALID_PERMS_ARRAY: IINVALID_PERMS_ARRAY;

interface IMISSING_URL {
  code: number;
  msg: string;
}

/**
 * @name MISSING_URL
 * @type {object}
 * @description Please provide URL
 * @property {number} code 1006
 * @property {string} msg
 */
declare var MISSING_URL: IMISSING_URL;

interface IINVALID_URL {
  code: number;
  msg: string;
}

/**
 * @name INVALID_URL
 * @type {object}
 * @description Please provide URL in string format.
 * @property {number} code 1007
 * @property {string} msg
 */
declare var INVALID_URL: IINVALID_URL;

interface IMISSING_AUTH_URI {
  code: number;
  msg: string;
}

/**
 * @name MISSING_AUTH_URI
 * @type {object}
 * @description Thrown when attempting to connect without authorisation URI.
 * @property {number} code 1008
 * @property {string} msg
 */
declare var MISSING_AUTH_URI: IMISSING_AUTH_URI;

interface INON_AUTH_GRANTED_URI {
  code: number;
  msg: string;
}

/**
 * @name NON_AUTH_GRANTED_URI
 * @type {object}
 * @description Thrown when attempting extract granted access permissions
 * from a URI which doesn't contain such information.
 * @property {number} code 1009
 * @property {string} msg
 */
declare var NON_AUTH_GRANTED_URI: INON_AUTH_GRANTED_URI;

interface IINVALID_PERM {
  code: number;
  msg: (() => any);
}

/**
 * @name INVALID_PERM
 * @type {object}
 * @description Thrown when invalid permission is requested on container.
 * @property {number} code 1010
 * @property {function} msg
 */
declare var INVALID_PERM: IINVALID_PERM;

interface IMISSING_CONTAINER_STRING {
  code: number;
  msg: string;
}

/**
 * @name MISSING_CONTAINER_STRING
 * @type {object}
 * @description Thrown when attempting to get a container without specifying name with a string.
 * @property {number} code 1011
 * @property {string} msg
 */
declare var MISSING_CONTAINER_STRING: IMISSING_CONTAINER_STRING;

interface INON_DEV {
  code: number;
  msg: string;
}

/**
 * @name NON_DEV
 * @type {object}
 * @description Thrown when functions unique to testing environment are attempted  to be used.
 * @property {number} code 1012
 * @property {string} msg
 */
declare var NON_DEV: INON_DEV;

interface IMISSING_PUB_ENC_KEY {
  code: number;
  msg: string;
}

/**
 * @name MISSING_PUB_ENC_KEY
 * @type {object}
 * @description Thrown when public encryption key is not provided as necessary function argument.
 * @property {number} code 1013
 * @property {string} msg
 */
declare var MISSING_PUB_ENC_KEY: IMISSING_PUB_ENC_KEY;

interface IMISSING_SEC_ENC_KEY {
  code: number;
  msg: (() => any);
}

/**
 * @name MISSING_SEC_ENC_KEY
 * @type {object}
 * @description Thrown when secret encryption key is not provided as necessary function argument.
 * @property {number} code 1014
 * @property {function} msg
 */
declare var MISSING_SEC_ENC_KEY: IMISSING_SEC_ENC_KEY;

interface ILOGGER_INIT_ERROR {
  code: number;
  msg: (() => any);
}

/**
 * @name LOGGER_INIT_ERROR
 * @type {object}
 * @description Logger initialisation failed.
 * @property {number} code 1015
 * @property {function} msg
 */
declare var LOGGER_INIT_ERROR: ILOGGER_INIT_ERROR;

interface ICONFIG_PATH_ERROR {
  code: number;
  msg: (() => any);
}

/**
 * @name CONFIG_PATH_ERROR
 * @type {object}
 * @description Informs you when config search path has failed to set, with specific reason.
 * @property {number} code 1016
 * @property {function} msg
 */
declare var CONFIG_PATH_ERROR: ICONFIG_PATH_ERROR;

interface IXOR_NAME {
  code: number;
  msg: (() => any);
}

/**
 * @name XOR_NAME
 * @type {object}
 * @description Custom name used to create public or private
 * MutableData must be 32 bytes in length.
 * @property {number} code 1017
 * @property {function} msg
 */
declare var XOR_NAME: IXOR_NAME;

interface INONCE {
  code: number;
  msg: (() => any);
}

/**
 * @name NONCE
 * @type {object}
 * @description Any string or buffer provided to private MutableData
 * that is not 24 bytes in length will throw error.
 * @property {number} code 1018
 * @property {function} msg
 */
declare var NONCE: INONCE;

interface ITYPE_TAG_NAN {
  code: number;
  msg: string;
}

/**
 * @name TYPE_TAG_NAN
 * @type {object}
 * @description Tag argument when creating private or public MutableData must be a number.
 * @property {number} code 1019
 * @property {string} msg
 */
declare var TYPE_TAG_NAN: ITYPE_TAG_NAN;

interface IINVALID_SEC_KEY {
  code: number;
  msg: (() => any);
}

/**
 * @name INVALID_SEC_KEY
 * @type {object}
 * @description Secret encryption key of improper length is provided to custom private MutableData
 * @property {number} code 1020
 * @property {function} msg
 */
declare var INVALID_SEC_KEY: IINVALID_SEC_KEY;


/**
 * @typedef {Object} AppInfo
 * holds the information about this app, needed for authentication.
 * @param {String} id - unique identifier for the app
 *        (e.g. 'net.maidsafe.examples.mail-app')
 * @param {String} name - human readable name of the app (e.g. "Mail App")
 * @param {String} vendor - human readable name of the vendor
 *        (e.g. "MaidSafe Ltd.")
 * @param {String=} scope - an optional scope of this instance
 * @param {String=} customExecPath - an optional customised execution path
 *        to use when registering the URI with the system.
 */
type AppInfo = Object;

/**
 * @typedef {Object} InitOptions
 * holds the additional intialisation options for the App.
 * @param {Boolean=} registerScheme to register auth scheme with the OS. Defaults to true
 * @param {Array=} joinSchemes to additionally register custom protocol schemes
 * @param {Boolean=} log to enable or disable back end logging. Defaults to true
 * @param {String=} libPath path to the folder where the native libs can
 *        be found. Defaults to current folder path.
 * @param {String=} configPath set additional search path for the config files.
 *        E.g. `log.toml` and `crust.config` files will be also searched not only
 *        in the same folder where the native library is, but also in this
 *        additional search path.
 * @param {Boolean=} forceUseMock to force the use of mock routing regardless
 *        the NODE_ENV environment variable value. Defaults to false
 */
type InitOptions = Object;


/**
 * @typedef {Object} WebFetchOptions
 * holds additional options for the `webFetch` function.
 * @param {Object} range range of bytes to be retrieved.
 * The `start` attribute is expected to be the start offset, while the
 * `end` attribute of the `range` object the end position (both inclusive)
 * to be retrieved, e.g. with `range: { start: 2, end: 3 }` the 3rd
 * and 4th bytes of data will be retrieved.
 * If `end` is not specified, the bytes retrived will be from the `start` offset
 * untill the end of the file.
 * The ranges values are also used to populate the `Content-Range` and
 * `Content-Length` headers in the response.
 */
type WebFetchOptions = Object;

/**
 * Helper to lookup a given `safe://`-url in accordance with the
 * convention and find the requested object.
 *
 * @param {String} url the url you want to fetch
 * @param {WebFetchOptions} [options=null] additional options
 * @returns {Promise<Object>} the object with body of content and headers
 */
declare function webFetch(url: String, options?: WebFetchOptions): Promise<Object>;

declare namespace SafeNodeApp {
  /**
   * The entry point to create a new SAFEApp
   * @param {AppInfo} appInfo
   * @param {Function} [networkStateCallBack=null] callback function
   *        to receive network state updates
   * @param {InitOptions=} options initialisation options
   *
   * @returns {Promise<SAFEApp>} promise to a SAFEApp instance
   * @example // Usage Example
   * const safe = require('@maidsafe/safe-node-app');
   *
   * // starting initialisation
   * let prms = safe.initialiseApp({
   *                      id: "net.maidsafe.example",
   *                      name: 'Example SAFE App',
   *                      vendor: 'MaidSafe.net Ltd'
   *                     });
   * // we want read & insert access permissions for `_pictures` and
   * // read access to `_videos` container:
   * const containers = { '_videos': ['Read'], '_pictures' : ['Read', 'Insert']}
   * prms.then(app => app.auth.genAuthUri(containers)
   *                    .then(uri => app.auth.openUri(uri))
   *        // now we either quit the programm
   *        // or wait for an authorisation URI
   *        )
   */
  export function initializeApp(appInfo: AppInfo, networkStateCallBack?: (() => any), options?: InitOptions): Promise<SAFEApp>;

  /**
   * If you have received a response URI (which you are allowed
   * to store securely), you can directly get an authenticated or non-authenticated
   * connection by using this helper function. Just provide said URI as the
   * second value.
   * @param {AppInfo} appInfo - the app info
   * @param {String} authUri - the URI coming back from the Authenticator
   * @param {Function} [networkStateCallBack=null] optional callback function
   * to receive network state updates
   * @param {InitOptions=} options initialisation options
   * @returns {Promise<SAFEApp>} promise to a SAFEApp instance
   */
  export function fromAuthURI(appInfo: AppInfo, authUri: String, networkStateCallBack?: (() => any), options?: InitOptions): Promise<SAFEApp>;

  export enum CONSTANTS {
    NFS_FILE_MODE_OVERWRITE = 1,
    NFS_FILE_MODE_APPEND = 2,
    NFS_FILE_MODE_READ = 4,
    NFS_FILE_START = 0,
    NFS_FILE_END = 0,
    USER_ANYONE = 0,
    MD_METADATA_KEY = '_metadata',
    MD_ENTRIES_EMPTY = 0,
    MD_PERMISSION_EMPTY = 0,
  }
}
